angular.module("ngBabelfish",[]).run(["$rootScope","babelfishLangLoader","marvin",function(a,n,t){a.$on(t.getRouteEvent(),function(a,t){n.updateState(t.name)}),n.load()}]),angular.module("ngBabelfish").directive("i18nBind",function(){return{restrict:"A",scope:{translationKey:"=i18nBind",translationLang:"@i18nBindLang"},template:"{{translationKey}}",link:function(){}}}),angular.module("ngBabelfish").directive("i18nLoad",function(){return{restrict:"A",link:function(a,n,t){n.on("click",function(){a.$apply(function(){translator.updateLang(t.i18nLoad)})})}}}),angular.module("ngBabelfish").factory("marvinI18nMemory",function(){var a={current:"",data:null,available:[],currentState:"",active:!1,previousLang:"en-EN",stateLoaded:!1};return{get:function(){return a}}}),angular.module("ngBabelfish").filter("babelfish",function(a){"use strict";return function(n,t,e){return a.get(t)[e]}}),angular.module("ngBabelfish").provider("marvin",function(){"use strict";var a={state:"home",lang:"en-EN",url:"/i18n/languages.json",routeEventName:"$stateChangeSuccess",namespace:"i18n",lazy:!1,lazyConfig:[],current:"",log:!0};this.init=function(n){angular.extend(a,n)},this.lang=function(n){if(!n.lang)throw new Error("[babelfishProvider@lang] You must set the key lang");if(!n.url)throw new Error("[babelfishProvider@lang] You must set the key url");return a.lazy=!0,a.urls.push(n),this},this.$get=function(n){return{getConfig:function(){return a},getRouteEvent:function(){return a.routeEventName},getNamespace:function(){return a.namespace},getDefaultLang:function(){return a.lang?(n.documentElement.lang=a.lang.split("-")[0],a.lang):n.documentElement.lang+"-"+n.documentElement.lang.toUpperCase()},getLazyLangAvailable:function(){return a.lazyConfig.map(function(a){return a.lang})},getLazyConfig:function(n){var t=n||this.getDefaultLang();return a.urls.filter(function(a){return a.lang===t})[0]||{}},getLazyConfigByUrl:function(n){return a.urls.filter(function(a){return a===n})[0]},isVerbose:function(){return a.log},isLazy:function(){return a.lazy},isSolo:function(){return console.log("[@todo] Need to implement solo mode"),!1}}}}),angular.module("ngBabelfish").service("babelfish",function(a,n){"use strict";function t(t){var e=n.data[t||n.current]||{},r={};return a.isSolo()?angular.extend({},n.data._common||{},e):(e[n.currentState]||(a.isVerbose()&&console.warn("[ngBabelfish-translator@get] No translation available for the page %s for the  lang %s",n.currentState,t||n.current),e[n.currentState]={}),angular.extend(r,{},e._common),angular.extend(r,e[n.currentState]))}function e(t){var e=t||n.current;return a.isSolo()?angular.extend({},n.data._common||{},n.data[e]||{}):n.data[e]}function r(){return n.data}function i(a){return!!n.data[a]}function o(){return n.current}function u(){return n.active}function l(){return n.available.indexOf("_comon")>-1&&n.available.splice(n.available.indexOf("_comon"),1),n.available}return{get:t,all:e,current:o,translations:r,languages:l,isLangLoaded:i,isLoaded:u}}),angular.module("ngBabelfish").service("babelfishLangLoader",function(a,n,t,e){"use strict";function r(a,n){var e=t.getLazyConfigByUrl(a);d.available=t.getLazyLangAvailable(),d.current=e.lang,d.currentState=n,lazyConfig.data&&(d.data[n]=lazyConfig.data)}function i(a,n){d.current=t.getDefaultLang(),d.currentState=n,d.data=t.data,d.available=Object.keys(t.data)}function o(a,n){d.data&&!d.data[d.current]&&(t.isLazy()&&r(a,n),t.data&&i(a,n),u(d.currentState))}function u(n){n=n||d.currentState||t.state;var e=d.current,r={},i={};d.currentState===n&&d.stateLoaded&&d.current===d.previousLang||(d.active=!0,d.data[e]&&(d.data[e][n]||(d.data[e][n]={},t.isVerbose()&&console.warn("[babelfishLangLoader@setTranslation] No translation available for the page %s for the lang %s",n,e)),angular.extend(i,d.data[e]._common),r=angular.extend(i,d.data[e][n]),t.getNamespace()?a[t.getNamespace()]=r:(angular.extend(a,r),t.isVerbose()&&console.warn("[babelfishLangLoader@setTranslation] It is better to Load i18n inside a namespace.")),d.stateLoaded=!0,t.isLazy()&&(angular.extend(i,d.data[e]._common),r=angular.extend(i,d.data[n]),config.namespace?a[config.namespace]=r:angular.extend(a,r)),a.$emit("ngBabelfish.translation:loaded",{currentState:n,lang:e})))}function l(){var n=d.current,e={},r={};n!==d.previousLang&&(d.active=!0,d.data[n]&&(angular.extend(r,d.data._common||{}),e=angular.extend(r,d.data[n]),t.getNamespace()?a[t.getNamespace()]=e:(angular.extend(a,e),t.isVerbose()&&console.warn("[babelfishLangLoader@setSoloTranslation] It is better to Load i18n inside a namespace.")),a.$emit("ngBabelfish.translation:loaded",{lang:n})))}function s(a,e){return a=a||t.getConfig().url,e=e||t.getConfig().state,t.isLazy()&&(a=t.getLazyConfig(d.current||t.getConfig().lang)),o(a,e),n.get(a).error(function(){if(t.isVerbose())throw new Error("[babelfishLangLoader@load] Cannot load the translation file")}).success(function(a){t.isLazy()?d.data[d.current]=a:(d.data=a,d.available=Object.keys(a))}).then(function(){t.isSolo()?l():u(d.currentState)})}function c(n){var e=t.getDefaultLang();n?(document.documentElement.lang=n.split("-")[0],d.previousLang=e):d.previousLang=n=e,d.current=n,a.$emit("ngBabelfish.translation:changed",{previous:e,value:n}),t.isLazy()&&!d.data[n]&&service.load(t.getLazyConfig(n).url,d.currentState)}function g(a){a[d.current]?d.data=a:d.data[d.current]=a,u()}var d=e.get();return a.$on("ngBabelfish.translation:changed",function(){t.isSolo()?l():u(d.currentState)}),{init:o,initLazy:r,initStaticData:i,updateState:u,setSoloTranslation:l,setStaticData:g,load:s,updateLang:c}});